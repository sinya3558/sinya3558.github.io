---
title:  "OpenCV (Part.2) : 기하학적 변환 (1) & 필터링 코드 실습"
description: "OpenCV 필터링 기법(Mean, Gaussian, Sharpening, Bilateral) 코드 실습 Part.1"
author: Seunga Kim
date: 2025-11-24
categories: [OpenCV, Computer Vision]
tag: [code snippet]
toc: true
toc_label: "Table of Contents"
author_profile: True
comments: false

---

# 22. OpenCV (Part.2) : 필터링 기법 코드 실습

<img src="/assets/img/gifs/monday.gif" width="300">

> 영역처리 (Area Processing)

## 22-1. 영상 필터링 (Filtering) : 평균 필터링 + 가우시안 필터링의 원리

### 블러링 (1) : 평균값 필터 (mean blur filter)

> 1 번(conv)와 2번 (blur) 는 동일. 함수를 직접 작성하느냐 아니냐의 차이

1. convolution 하는 방법 :

    ```python
    cv2.filter2D(src, ddepth, kernel[, dst[, anchor[, delta[, borderType]]]]) -> dst
    # src : 입력영상
    # ddepth : 출력영상의 타입 (옵션1: cv2.CV_8U, cv2.CV_32F, cv2.CV_64F), 옵션2: -1(입력 영상과 동일 타입) - 보통의 경우 uint8
    # kernel : filter 행렬, 실수형
    # anchor : (-1, -1) 필터의 중앙점
    # delta : 더할 값
    # borderType : 가장자리 픽셀 확장 방식
    # dst : 출력 영상
    ```

2. blur 하는 법 :

    ```python
    blur(src, ksiz[, dst[, anchor[, borderType]]]) -> dst
    # src : 입력영상
    # ksize, mean filter kernel size
    ```


```python
import sys
import numpy as np
import matplotlib.pyplot as plt
import cv2

# 이미지 경로 Path 위한 임포트
from pathlib import Path
```


```python
folder = "./fig"
```

### Mean Blurring Filter

> 필터의 크기가 커질수록 연산량은 급증한다. 실시간 검출일 경우 커널 사이즈 유의할 것

- 3x3 filter


```python
src = cv2.imread(Path(folder, "eyes.jpg"))

# 3x3 커널 필터 만들기
kernel_3 = np.ones((3, 3))  # 모든 elements = 1
kernel_3 = kernel_3/9.0     # 커널의 모든 요소들의 합이 1이 되도록 조절

# convolution 
dst_kernel = cv2.filter2D(src, -1, kernel_3)

cv2.imshow("original", src)
# conv 결과 확인
cv2.imshow("dst_kernel", dst_kernel)


while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

### 결과 비교

- 원본 이미지 / 3x3 convolution 적용 이미지

![image.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20181605.png)

---

- 5x5 filter
- 7x7 filter


```python
src = cv2.imread(Path(folder, "eyes.jpg"))

# 여러가지 사이즈의 커널 필터 만들기 for mean blurring filter
# 3x3
kernel_3 = np.ones((3, 3)) 
kernel_3 = kernel_3/9.0  
# 5x5
kernel_5 = np.ones((5, 5))/25.0 # mbf
# 7x7
kernel_7 = np.ones((7, 7))/49.0 # mbf

# convolution 
dst_kernel3 = cv2.filter2D(src, -1, kernel_3)
dst_kernel5 = cv2.filter2D(src, -1, kernel_5)
dst_kernel7 = cv2.filter2D(src, -1, kernel_7)

cv2.imshow("original", src)
# conv 결과 확인
cv2.imshow("dst_kernel 3", dst_kernel3)
cv2.imshow("dst_kernel 5", dst_kernel5)
cv2.imshow("dst_kernel 7", dst_kernel7)


while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

### 결과 확인

- 원본 / 3x3 / 5x5 / 7x7

![image.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20182229.png)

---

### blur 함수 사용하여 convolution 적용하기


```python
src = cv2.imread(Path(folder, "eyes.jpg"))

# 여러가지 사이즈의 커널 필터 만들기 for mean blurring filter
# 3x3
kernel_3 = np.ones((3, 3))/9.0

# convolution 
dst_kernel3 = cv2.filter2D(src, -1, kernel_3)

# blur 함수
dst_blur3 = cv2.blur(src, (3, 3))

cv2.imshow("original", src)
# conv 결과 확인
cv2.imshow("dst_kernel 3", dst_kernel3)
# blur 결과 확인
cv2.imshow("dst_blur 3", dst_blur3)

while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

### 결과 비교

- 원본 / conv 3x3 / blur 함수 이용한 3x3

![image.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20183210.png)

---


```python
# 블러링 필터 비교 가능한 조각코드 : 'q' 입력하면 종료

src = cv2.imread(Path(folder, "eyes.jpg"))

cv2.imshow('src', src)

for k_size in (3, 5, 7, 9, 13, 15, 17):
    dst = cv2.blur(src, (k_size, k_size))
    text = f"{k_size}x{k_size}"
    cv2.putText(dst, text, (10, 30), cv2.FONT_HERSHEY_PLAIN, 2, (0, 0, 255), 1, cv2.LINE_AA)
    cv2.imshow("dst", dst)

    while True:
        if cv2.waitKey() == ord("q"):
            break

cv2.destroyAllWindows()

```

---

### 블러링 (2) : 가우시안 필터 (Gaussian filter)

1. 가우시안 필터의 커널(kernel)

![스크린샷 2025-11-24 172522.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20172522.png)

- 직접 만드는게 더 편하다



```python
gaussian_kernel = np.array([
    [1/16, 1/8, 1/16,],
    [1/8, 1/4, 1/8],
    [1/16, 1/8, 1/16]
])

dst_gaussian = cv2.filter2D(src, -1, gaussian_kernel)

cv2.imshow("src", src)
cv2.imshow("gaussian", dst_gaussian)

while True:
        if cv2.waitKey() == ord("q"):
            break

cv2.destroyAllWindows()
```

### 결과 비교

![image.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20211831.png)

## Gaussian filter 함수 이용해서 생성

```python

GaussianBlur(src, (k_size), sigmaX[, dst[, sigmaY[, borderType]]]) -> dst

# src : 입력영상
# k_size : mean filter kernel size,  (0, 0) 자동으로 결정 -> 이건 거의 사용 X, 대신 시그마를 지정해줌
# sigmaX : gaussian x 방향의 sigma, 표준편차 1
# sigmaY : gaussian Y 방향의 sigma

```

1. 시그마 = 1 인 경우
2. 시그마 = 0.5 인 경우
3. 시그마 = 2 인 경우


```python
gaussian_kernel = np.array([
    [1/16, 1/8, 1/16,],
    [1/8, 1/4, 1/8],
    [1/16, 1/8, 1/16]
])

gaussian_call = cv2.GaussianBlur(src, (0, 0), sigmaX= 2.0)

cv2.imshow("src", src)
cv2.imshow("gaussian", gaussian_call)

while True:
        if cv2.waitKey() == ord("q"):
            break

cv2.destroyAllWindows()
```

### 결과 확인

1. original / gaussian(sigma = 1)

![image.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20212404.png)

2. original / gaussian (sigma = 0.5)

![image-2.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20212536.png)

3. original / gaussian (sigma = 2.0)

![image-3.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20212622.png)

---



## 22-2. 샤프닝 필터링, 양방향 필터링 원리

### 샤프닝 (Sharpening) 필터

> sharpening >> gaussian 필수

- `f(x)` : 자기 자신
- shapening filter = `2 * f(x) - Gaussian(f(x))`


```python
## 2*f(x) - Gaussian(f(x)) => shapening filter
src_duck = cv2.imread(Path(folder, "ducks.jpg"))

# (1) Gaussian filter 시그마 = 3
blur_duck3 = cv2.GaussianBlur(src_duck, (0, 0), 3.0)
blur_duck2 = cv2.GaussianBlur(src_duck, (0, 0), 2.0)
blur_duck1 = cv2.GaussianBlur(src_duck, (0, 0), 1.0)

# (2) Sharpening filter 적용
'''
- src_duck : f(x)
- blur_duck : Gqaussian
=> 2 * f(x) - Gaussian(f(x) == 2 * src_duck - (blur_duck)
'''
dst_duck = cv2.addWeighted(src_duck, 2, blur_duck1, -1, 0.0) # gamma 는 없음
dst_duck2 = cv2.addWeighted(src_duck, 2, blur_duck2, -1, 0.0) # gamma 는 없음
dst_duck3 = cv2.addWeighted(src_duck, 2, blur_duck3, -1, 0.0) # gamma 는 없음

cv2.imshow("src", src_duck)
cv2.imshow("shap1", dst_duck)
cv2.imshow("shap2", dst_duck2)
cv2.imshow("shap3", dst_duck3)

while True:
        if cv2.waitKey() == ord("q"):
            break

cv2.destroyAllWindows()
```

### 결과 비교

1. 원본 / 가우시안 블러 : 시그마 1 일 때

![image.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20214544.png)

2. 원본 / 가우시안 : 시그마 2 일 때

![image-2.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20214634.png)

3. 원본 / 가우시안 : 시그마 3 일 때

![image-3.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20214648.png)

4. 시그마 1 / 시그마 2 / 시그마 3 샤프닝 필터 결과 비교 이미지

![image-4.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20214837.png)

---


###  블러링(3) : 양방향 필터 (Bilateral Filter)

> 가우시안 필터링의 취약점을 보완한 블러링 기법. 가우시안 필터보다 처리 시간이 더 오래 걸리지만, 더 나은 품질의 이미지를 만들어 낼 수도 있다

```python
bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]]) -> dst
# src : 입력영상
# d : 아웃풋 이미지, -1 로 설정하면 인풋과 동일한 디멘션이 출력

## 표준편차? : 주변 범위를 얼마나 포함할것인가 (가우시안 커브의 너비 (크면 납작 호떡, 작으면 유니콘 뿔))
# sigmaColor : 색공간의 표준편차 (색상에 대하여)
# sigmaSpace : 좌표공간의 표준편차 (공간에 대해서)
# dst : 출력 영상
# borderType : 가장자리 픽셀확장 방식

```


```python
src_dune= cv2.imread(Path(folder, "dune.jpg"))

if src_bird is None:
    print("Image can not read")
    sys.exit()

# (1) Gaussian
dst_gaussian = cv2.GaussianBlur(src_dune, (0, 0), 1)  # 시그마 = 1

# (2) Bilateral
dst_bilateral = cv2.bilateralFilter(src_dune, -1, 5, 10)

cv2.namedWindow('src', cv2.WINDOW_AUTOSIZE)
cv2.imshow("src", src_dune)
cv2.imshow("Gaussian", dst_gaussian)
cv2.imshow("Bilateral", dst_bilateral)

while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindow()
```



### 결과 비교 : bluring

##### 가우시안 vs. 양방향 필터의 블러링 효과

- original / gaussian / bilateral filter 

![image.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20224257.png)

- 가우시안과 양방향 둘 다 블러처리 되었으나, 양방향 필터가 상당히 원본의 값을 유지한채로 블러링 된 상태


```python
# (1) Gaussian
dst_gaussian = cv2.GaussianBlur(src_dune, (0, 0), 1)  # 시그마 = 1

# (2) Bilateral
dst_bilateral = cv2.bilateralFilter(src_dune, -1, 5, 10)
dst_bilateral_wide = cv2.bilateralFilter(src_dune, -1, 50, 10)

cv2.namedWindow('src', cv2.WINDOW_AUTOSIZE)
cv2.imshow("src", src_dune)
cv2.imshow("Bilateral", dst_bilateral)
cv2.imshow("Bilateral (wide range)", dst_bilateral_wide)

while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

### 결과 비교 : 양방향 only

##### 양방향 필터의 블러링

- original / bilateral (색상 시그마 : 5) / bilateral (색상 시그마 : 50)

![image.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20224656.png)

### (optional) 카툰 필터 (Cartoon Filter)

1. 두 가지의 이미지를 가지고 비트와이즈 연산
    - 픽셀별로 계산


```python
## bitwise operator

src1 = np.zeros((256, 256), np.uint8)
cv2.rectangle(src1, (10, 10), (127, 245), 255, -1)
src2 = np.zeros((256, 256), np.uint8)
cv2.circle(src2, (127, 127), 100, 128, -1)

dst1 = cv2.bitwise_and(src1, src2)
dst2 = cv2.bitwise_or(src1, src2)
dst3 = cv2.bitwise_xor(src1, src2)
dst4 = cv2.bitwise_not(src1)

cv2.imshow('src1', src1)
cv2.imshow('src2', src2)
cv2.imshow('and', dst1)
cv2.imshow('or', dst2)
cv2.imshow('xor', dst3)
cv2.imshow('not', dst4)

while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

## 결과 

- src1 / src2 
- and / or / xor / not

![image-2.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20230043.png)


2. 카툰 필터링
    - 1.블러링
    - 2.엣지 검출


```python
src = cv2.imread(Path(folder, "shihtzu.jpg"))

# 카툰 필터링을 위한 블러링
## 블러링의 종류 : (1) 평균 필터 (2) 가우시안 필터 (3) 양방향 필터
# (1) Gaussian 선택 - 내 마음
blr = cv2.GaussianBlur(src, (0, 0), 1)

# (2) 외각선 만들어주기 - edge detection
edge = cv2.Canny(src, 100, 200)
## 외각선 색상 반전
edge_white = 255 - edge
## 흑백 -> 컬러 뱐환
edge = cv2.cvtColor(edge_white, cv2.COLOR_GRAY2BGR)
dst = cv2.bitwise_and(blr, edge)

cv2.imshow('src', src)
cv2.imshow('blur', blr)
# cv2.imshow('edge', edge)
cv2.imshow('edge white', edge_white)
cv2.imshow('cartoon', dst)


while True:
    if cv2.waitKey() == ord('q'):
        break

cv2.destroyAllWindows()
```

### 결과 확인

- 원본 / 블러 / 엣지 검출(색상 반전) / 카툰 필터

![image.png](/assets/img/opencv/2_opencv2_실습_files/스크린샷%202025-11-24%20231359.png)
