---
title:  "OpenCV (2) : 기하학적 변환 — Affine & Perspective 실습"
description: "OpenCV를 이용한 Geometric(이동, 회전, 확대, 전단 변환), Perspective Transform 을 실습과 함께 정리한 Part.2"
author: Seunga Kim
date: 2025-11-25
categories: [Computer Vision, OpenCV]
tag: [geometric transform]
toc: true
toc_label: "Table of Contents"
author_profile: True
comments: false
---
# 22. CV2 를 이용한 영상 기하학적 변환 (Geometric transform)

> Affine 변환과 Perspective 변환을 통해 영상의 위치, 크기, 방향을 마음대로 변형한 코드 블럭 모음

## 영상 이동 (Translation)

> Affine 변환 : 영상 확대, 축소, 이동, 기울이기, 회전 등 모든 변환은 affine transform 에 속한다

- **Translation** 용 Affine Matrix :

    - `[[1, 0, tx],
        [0, 1, ty]]`

    - 예시 : x축 50, y축 200 이동: 
       - `[[  1.   0.  50.]
            [  0.   1. 200.]]`

- warpAffine :
    - warp : 펴준다
    - warpAffine : 아핀 변환을 펴준다

- warpAffine 기본 구조

```python
warpAffine(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) -> dst
# src : input
# M : affine transform matrix (size : 2x3)
# dsize : output size,  (0, 0) -> same as input size
# borderValue : filling value of empty space, default = 0 (검정색으로 채우기)

```
### 이미지 이동

```python
src = cv2.imread(Path(folder, "hummingbirds.jpg"))

## affine transform - translation
affine = np.array([
        [1, 0, 50], # x축 이동
        [0, 1, 200] # y축 이동   
], np.float32)
height, width = src.shape[:2]


dst = cv2.warpAffine(src, affine, (0, 0), borderMode= None)

# 확인
print("affine matrix = \n", affine)

cv2.imshow("src", src)
cv2.imshow("translation", dst)

while True:
    if cv2.waitKey() == ord("q"):
        break
cv2.destroyAllWindows()
```

    affine matrix = 
     [[  1.   0.  50.]
     [  0.   1. 200.]]
    

#### 결과 비교

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20113155.png)

- [그림1] 이동하고 비어있는 공간은 검은색 (borderValue=0)

![image-2.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20113712.png)

- [그림2] 이동하고 비어있는 공간 (border) 를 따로 지정해준 경우 (`borderMode`로 배경 변경 가능)

### 이미지 이동 후, 원본 이미지가 크롭되지 않게 Fit 시키기

- `(0, 0) -> (움직인 delta_x + 가로 길이, delta_y + 세로길이)`


```python
dst_fit = cv2.warpAffine(src, affine, (width + 50, height + 200))
```

#### 결과 비교 

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20114253.png)

## 회전 변환 (Rotation)

> 회전 변환시 주의할 점 : (1) center point(0, 0) 이동 후 >> 회전 변환 (2) 회전 완료 후 >> original coordinates 로 다시 이동


```python
getRotationMatrix2D(center, angle, scale) -> retval
# center : center point of video(image)
# angle : degree of rotation(°)
# scale : scaling percentage, 1 = same, 2 = double scale
```

### 이미지 회전 

```python
src = cv2.imread(Path(folder, "cat.jpg"))

## 
h, w = src.shape[:2]
center_pt= (w//2, h//2)
rotation_affine = cv2.getRotationMatrix2D(center_pt, -30, 1)
# print rot_affine
print("roation affine matrix = \n", rotation_affine)

dst = cv2.warpAffine(src, rotation_affine, (0, 0))

cv2.imshow("src", src)
cv2.imshow("roatation", dst )
```

    roation affine matrix = 
     [[   0.8660254    -0.5         149.37187079]
     [   0.5           0.8660254  -131.46341101]]
    

#### 결과 확인
- 원본 / +30 도 회전

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20120126.png)

- 원본 / -30 도 회전

![image-2.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20120225.png)

## 영상 확대 (Scaling)

- scale affine 변환 매트릭스 :
    - `[[sx, 0, 0],
 [0, sy, 0]]`

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20121020.png)

### 이미지 확대

```python
src = cv2.imread(Path(folder, "rabbit.jpg"))

# scale affine
scale_affine = np.array(
    # 1.5 배 확대
    [[1.5, 0, 0],
    [0, 1.5, 0]], np.float32)

dst_affine = cv2.warpAffine(src, scale_affine, (0, 0), )

dst_resize = cv2.resize(src, None, fx= 1.5, fy= 1.5)   # resize 를 이용한 2배 확대

cv2.imshow("src", src)
cv2.imshow("scaled by affine matrix", dst_affine)
cv2.imshow("scaled by resize", dst_resize)
```

#### 결과 비교

- 원본 / affine 을 이용한 1.5 확대 / resize 를 이용한 1.5 확대

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20121401.png)

- 결론 : 실제 확대 작업은 cv2.resize()가 훨씬 간단하고 일반적

#### resize 의 interpolation 옵션

> interploation 이란? 확대는 **없는 픽셀을 채워넣어**야 하기 때문에 interploation 사용

- cv2.INTER_LINEAR → 가장 빠르지만 계단 현상
- cv2.INTER_NEAREST → 기본값, 속도·품질 균형
- cv2.INTER_CUBIC → 가장 부드럽지만 느림

### 이미지 확대 (w/ 보간법)

```python
src = cv2.imread(Path(folder, "rabbit.jpg"))

src = src[70:270, 250:450]
h, w = src.shape[:2]
print(f"원본 이미지 세로x가로 = {h}x{w}")   # 427x640

k = 4

dst_resize_lin = cv2.resize(src, (k*w, k*h), interpolation= cv2.INTER_LINEAR)
dst_resize_nearest = cv2.resize(src, (k*w, k*h), interpolation= cv2.INTER_NEAREST)
dst_resize_cubic = cv2.resize(src, (k*w, k*h), interpolation= cv2.INTER_CUBIC)

cv2.imshow("src", src)
cv2.imshow("linear", dst_resize_lin)
cv2.imshow("nearest", dst_resize_nearest)
cv2.imshow("cubic", dst_resize_cubic)
```

    원본 이미지 세로x가로 = 200x200
    

#### 결과

- Nearest / LInear / Cubic

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20122810.png)

- 이미지 결과 : 상대적으로 가장 거친 표현(육안으로 픽셀 확인 가능) く nearest 보다 나음 く Cubic 이 가장 부드러움
- 연산 속도 : nearest(가장 가벼운) ＞ linear ＞ cubic 
- 결론 : 무난하게 중간인 Linear 가 default 값이다

> 확대 비율이 동일하더라도, interpolation 설정에 따라서 이미지 결과가 다른 것을 확인 할 수 있다

## 전단변환 (Shearing) 

> Shearing(Skew)은 한 축 또는 두 축 방향으로 이미지가 밀려 기울어지는 변환이다

- skew(shaering) affine matrix: 

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20142731.png)

### 이미지 기울이기

```python
src = cv2.imread(Path(folder, "shiba.jpg"))

# shearing affine matrix
shear_affine = np.array([[1, 0.2, 0],   # shearing 0.2
                        [0, 1, 0]], np.float32) 

dst = cv2.warpAffine(src, shear_affine, (0, 0))

cv2.imshow("src", src)
cv2.imshow("shearing", dst)
```

#### 결과 비교 : shearing (=skew transform)

- 원본 / shearing affine

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20142340.png)

- 왜 밀릴까?
    - shearing affine matrix = `[[1, 0.2, 0], [0, 1, 0]]`

        - x축만 shearing = 0.2 -> x 값이 0.2 씩 밀린다
        - y축은 그대로
    
        즉, y 축 증가할 때마다 x 축은 0.2 픽셀씩 밀린다

### 이미지가 짤리지 않게 Fit

- 따로 지정하지 않고 shearing 진행하면 이미지 부분 손실일어남(짤림)

#### 코드
```python

dst_fit = cv2.warpAffine(src, shear_affine, (w + int(0.2*h), h))
```


#### 전체 적용
```python
# shearing affine matrix
shear_affine = np.array([[1, 0.2, 0],   # shearing 0.2
                        [0, 1, 0]], np.float32) 

h, w = src.shape[:2]

dst_fit = cv2.warpAffine(src, shear_affine, (int(w + 0.2*h), h))

cv2.imshow("src", src)
cv2.imshow("shearing_fit", dst_fit)
```

#### 결과 확인

- 원본 / shearing(fit)

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20144111.png)

#### Shearing : x 축과 y 축 동시 Skew

```python
# shearing affine matrix
shear_affine_xy = np.array([[1, 0.2, 0],   # shearing 0.2 (x-axis)
                            [0.2, 1, 0]], np.float32) # shearing 0.2 (y-axis)

h, w = src.shape[:2]

dst_xy = cv2.warpAffine(src, shear_affine_xy, (int(w + 0.2*h), int(h + 0.2*w)))

cv2.imshow("src", src)
cv2.imshow("shearing", dst)
cv2.imshow("shearing_fit", dst_fit)
cv2.imshow("shearing_xt", dst_xy)
```

#### 결과 비교

- 일반 전단변환 / fit 전단변환 / x,y 축 모두 전단변환

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20144611.png)


## 비선형 변환 : Prospective Transform

> Perspective Transform은 Affine보다 자유도가 높은 비선형 변환이다.
4개의 점을 기준으로 이미지를 ‘펴기(Unwarping)’를 할 수 있다

#### 변환 행렬 생성 함수

```python

getPerspectiveTransform(src, dst[, solveMethod]) -> retval
# src : 입력 영상의 4 개 좌표점, numpy array shape(4, 2)
# dst : 출력 영상의 4개 좌표점, numpy array shape(4, 2)
```
### 이미지 비선형 변환 : 특정 부분만 펴기(Unwarping)

```python
src_board= cv2.imread(Path(folder, "dice.jpg"))

h, w = src_board.shape[:2]

# 좌표 추출용
rect1 = cv2.selectROI(src_board)
print("corner coordinates = ", rect1)  # (119, 158, 194, 176) (x, y, w, h)

while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

    corner coordinates =  (190, 174, 236, 163)
    

#### 결과 확인 : Perspective transform (ROI 좌표)

- ROI (사각형 네 꼭지점) 잡아주는 기준점 좌표

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20151742.png)

- ROI 좌표 : `(x, y, width, height)`
    
    - 시계 방향으로
    1. upper_left =  (180, 156, 27, 37)
    2. upper_right = (376, 162, 62, 45)
    3. bottom_right = (384, 318, 72, 39)
    4. bottom_left =  (186, 315, 71, 58)



```python
# 변환시킬 영역 지정
srcPoint = np.array(
[   # 변환하고 싶은 이미지의 영역 4 꼭지점에 대한 x, y 좌표 (clockwise)
    [180, 156], 
    [376, 162],
    [384, 318],
    [186, 315]], np.float32)

dstPoint = np.array([[0, 0], [w-1, 0], [w-1, h-1], [0, h - 1]], np.float32)

perspective = cv2.getPerspectiveTransform(srcPoint, dstPoint)
print("perspective = \n", perspective)


```

    perspective = 
     [[ 3.18095976e+00 -1.20036217e-01 -5.53847107e+02]
     [-8.24777154e-02  2.69427204e+00 -4.05460449e+02]
     [-9.88812054e-05  7.25042023e-05  1.00000000e+00]]
    

#### 결과 확인

- perspective matrix 결과 값 : 

    ![스크린샷 2025-11-25 154015.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20154015.png)

    - 고정값 1 을 제외하고 남은 8항은 사용한다


```python
dst = cv2.warpPerspective(src_board, perspective, (0, 0))

cv2.imshow("Original", src_board)
cv2.imshow("Perspective", dst)

while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

#### 결과 비교

- 원본 / perspective 영역

![image.png](/assets/img/opencv/2_opencv22_실습_files/스크린샷%202025-11-25%20154300.png)

## Perspective Transform (비선형 변환) 예시 2

- 한번 더 해봤다
- 예시 : 책에 대해서 네 개의 좌표를 기준으로 재배치 및 평탄하게 펴기 


```python
src_b= cv2.imread(Path(folder, "book.png"))

h, w = src_b.shape[:2]

# 좌표 추출용
# rect1 = cv2.selectROI(src_b)
# print("corner coordinates = ", rect1)  # (119, 158, 194, 176) (x, y, w, h)

# 변환시킬 영역 지정
srcPoint = np.array(
[   # 변환하고 싶은 이미지의 영역 4 꼭지점에 대한 x, y 좌표 (clockwise)
    [88, 111], 
    [326, 107],
    [364, 426],
    [52, 421]], np.float32)

dstPoint = np.array([[0, 0], [w-1, 0], [w-1, h-1], [0, h - 1]], np.float32)

perspective = cv2.getPerspectiveTransform(srcPoint, dstPoint)
print("perspective = \n", perspective)

dst = cv2.warpPerspective(src_b, perspective, (0, 0))

cv2.imshow("Original", src_b)
cv2.imshow("Perspective", dst)


while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

    perspective = 
     [[ 1.99538175e+00  2.31721752e-01 -2.01314709e+02]
     [ 4.15999696e-02  2.47519819e+00 -2.78407797e+02]
     [ 1.39536811e-04  1.13957542e-03  1.00000000e+00]]
    

![image.png](/assets/img/opencv/2_opencv22_실습_files/image.png)

- ROI 좌표 :
    1. upper_left =  (88, 111, 67, 60)
    2. upper_right = (326, 107, 62, 52)
    3. bottom_right =  (364, 426, 43, 58)
    4. bottom_left =  (52, 421, 72, 64)

#### 결과 확인

- 원본 / perspective transform

![image-2.png](/assets/img/opencv/2_opencv22_실습_files/image-2.png)
