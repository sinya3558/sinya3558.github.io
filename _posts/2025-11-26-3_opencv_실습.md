---
title:  "OpenCV (3) : 객체 검출 (Part.1) & 엣지, 직선 검출 코드 실습"
description: "OpenCV를 이용해 Sobel 및 Canny Edge Detection, Hough Transform 직선 검출까지 객체 검출의 기초를 실습한 Part.3"
author: Seunga Kim
date: 2025-11-26
categories: [Computer Vision, OpenCV]
tag: [edge detection, sobel, canny, hough]
toc: true
toc_label: "Table of Contents"
author_profile: true
comments: false
---

# 23. OpenCV를 이용한 동영상 처리 및 객체 검출 (Part.1)

> 엣지(edge) 를 검출하는 기본 연산부터,
직선(line) 을 찾아내는 Hough Transform까지
객체 검출 실습해봄

호오..`ctrl + enter` 하니까 셀 자동실행이 된다. 처음알았다


## ***Sobel 필터*** 를 이용한 엣지 검출 (1) - 직접 커널 생성

> Sobel 필터는 x·y 방향 미분을 이용해 엣지를 검출하는 대표적인 1차 미분 연산자다

- x / y 방향 각각의 엣지를 비교해 보면, `x는 수직`, `y는 수평` 방향에 대해서 강하게 반응함

### (1) Sobel 필터 변환 (X 축)

```python
# Sobel Edge Dtection 은 grayscale opearator
src = cv2.imread(Path(folder, "leaf.jpg"), cv2.IMREAD_GRAYSCALE)

kernel_dx = np.array([
    [-1, 0, 1],
    [-2, 0, 2],
    [-1, 0, 1]], np.float32)

# convolution : 기억안나면 이전 포스트 function def 다시 보고 오기
dst_gx = cv2.filter2D(src, -1, kernel_dx)   # np.int8

cv2.imshow("src", src)
cv2.imshow("x-dir", dst_gx)
```

#### 결과 비교 : X 축 방향 sobel 엣지 검출

- 원본 / x-direction Sobel

![image.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-25%20180958.png)

### (2) Sobel 필터 변환 (Y 축)

```python
# x, y  both direction 

kernel_dy = np.array([
    [-1, -2, -1],
    [0, 0, 0],
    [1, 2, 1]], np.float32)

# dst_gy = cv2.filter2D(src, -1, kernel_dy)   # np.int8
dst_gy = cv2.filter2D(src, -1, kernel_dx.T) # x-dir 커널을 transpose 해서 넣어도 동일한 결과 나옴!

cv2.imshow("src", src)
cv2.imshow("x-dir", dst_gx)
cv2.imshow("y-dir", dst_gy)
```

#### 결과 비교

- 원본 / x-dir / y-dir

![image.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-25%20181403.png)

## ***Sobel 필터 함수*** 를 이용한 엣지 검출 (2) - opencv 제공 함수

> 2. oepncv 가 제공하는 ***sobel 필터 함수*** 사용 

#### Sobel 필터 함수 + Gradient Magnitude 계산 함수
```python
Sobel(src, ddepth, dx, dy, dst, ksize, scale, delta, borderType) -> dst
# src : input
# ddepth : *data type* of output (-1 : same as an input)
# dx : x-axis 미분 차수
# dy : y-axis 미분 차수
# dst : output
# ksize : size of kernel
# sclae : 연산결과에 추가적으로 곱할 값
# delta : 연산결과에 추가적으로 더할 값
# borderType : 가장자리 픽셀확장 방식

magnitude(x, y, magnitude) -> magnitude
# x : x-dir
# y : y-dir
# magnitude : 밝기 크기 변화
```
- 실제 엣지는 x-엣지, y-엣지 두 가지이기 때문에 피타고라스를 이용해 magnitude 로 구해야한다


```python
# Sobel => grayscale opearator
src = cv2.imread(Path(folder, "leaf.jpg"), cv2.IMREAD_GRAYSCALE)

# d : derivative or differential
dx = cv2.Sobel(src, -1, 1, 0)  # dx = 1 -> x 방향으로 convolution 진행해라
dy = cv2.Sobel(src, -1, 0, 1)  # dy = 1 -> y 방향으로 컨볼루션 해라
# -------------------------

cv2.imshow("src", src)
cv2.imshow("x-dir(sobel)", dx)
cv2.imshow("y-dir(sobel)", dy)
# -------------------------
# 비교 
cv2.imshow("x-dir(manual)", dst_gx)
cv2.imshow("y-dir(manual)", dst_gy)

```

#### 결과 확인 : opencv 제공하는 `Sobel() 함수`를 이용하여 엣지 검출

- 원본 / x_dir / y_dir

![image.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-25%20182907.png)

##### manual vs opencv Sobel 비교

- x-dir(manual) / x-dir(Sobel) / 원본 / y-dir(manual) / y-dir(Sobel)

![image-2.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-25%20183711.png)

- 결과가 동일


##### Magnitude 구하기

`G = sqrt(Gx2+Gy2)`

```python
# Sobel => grayscale opearator
src = cv2.imread(Path(folder, "leaf.jpg"), cv2.IMREAD_GRAYSCALE)

# d : derivative or differential
gx = cv2.Sobel(src, cv2.CV_32F, 1, 0)  # gx = 1 -> x 방향으로 convolution 진행해라
gy = cv2.Sobel(src, cv2.CV_32F, 0, 1)  # gx = 1 -> y 방향으로 컨볼루션 해라
# -------------------------
# magnitude
# magnitude = np.sqrt(dx**2 + dy**2)
mag = cv2.magnitude(gx, gy).astype(np.uint8)
mag = np.clip(mag, 0, 255).astype(np.uint8)  # 클리핑 실행 후, uint8 로 지정

cv2.imshow("src", src)
cv2.imshow("x-dir(sobel)", gx)
cv2.imshow("y-dir(sobel)", gy)
cv2.imshow("magnitude", mag)
```

#### 결과 확인

- x-label / 원본 / y-label / magnitude

![스크린샷 2025-11-25 204927.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-25%20204927.png)

## Thresholding : 역치, 기준, maximum value 제어

- 특정 임계값 이상인 픽셀 값들만 보존 → 엣지로 선택
- 특정 값 미만인 값들은 0 처리

### 임계값 구분

```python
# Sobel => grayscale opearator
src = cv2.imread(Path(folder, "leaf.jpg"), cv2.IMREAD_GRAYSCALE)

# d : derivative or differential
gx = cv2.Sobel(src, cv2.CV_32F, 1, 0)  # gx = 1 -> x 방향으로 convolution 진행해라
gy = cv2.Sobel(src, cv2.CV_32F, 0, 1)  # gx = 1 -> y 방향으로 컨볼루션 해라
# -------------------------
# magnitude
mag = cv2.magnitude(gx, gy).astype(np.uint8)
mag = np.clip(mag, 0, 255).astype(np.uint8)  # 클리핑 실행 후, uint8 로 지정

# thresholding
ret_val, mask = cv2.threshold(mag, 150, 255, cv2.THRESH_BINARY)   # 150 이상은 모두 255


cv2.imshow("src", src)
cv2.imshow("magnitude", mag)
cv2.imshow("mask", mask)
```

#### 결과 비교

- 원본 / magnitude / threshold mask (T = 150)

![image.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-25%20205728.png)

---

## ***Canny Edge*** 를 이용한 영상 엣지 검출

> Canny는 Sobel 기반의 Gradient + 노이즈 제거 + Non-Maximum Suppression + Hysteresis Thresholding 전부 포함

- threshold1: low threshold
- threshold2: high threshold

```python
Canny(image, threshold1, threshold2, edges, apertureSize, L2gradient) -> edges
# images: 입력 영상
# threshold1 : 엣지 결정 하한값 (min.threshold) >> 미만이면 무조건 edge x
# threshold2 : 엣지 결정 상한값 (max.threshold) >> 넘으면 무조건 edge o
# edges : None
# apertureSize : 커널 사이즈
# L2gradient : gradient 크기 계산, False
```
- Threshold 조절에 따라 검출 민감도가 크게 달라짐

### Canny 엣지 검출

```python
# Sobel filter 사용했을 땐, grayscale 이였다
src = cv2.imread(Path(folder, "leaf.jpg")) 

dst0 = cv2.Canny(src, 100.0, 150.0) 
dst1 = cv2.Canny(src, 150.0, 200.0)  # threshold1, 2 는 hyperparameters (조절 가능)
dst2 = cv2.Canny(src, 200.0, 250.0)

cv2.imshow("src", src)

while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

#### 결과 확인

- 원본 / Canny 엣지 검출

![image.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-25%20221642.png)

- Canny(low threshold) / Canny (mid) / Canny (high threshold)

![image-2.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-25%20221922.png)

## Hough Transform 사용한 직선 검출

> 완벽하게 직선을 검출하진 못하지만, 이미지 공간안에서 직선을 찾을 수 있다는 것이 의미 있음 -> ***이미지의 직선은 (ρ, θ) 공간에서는 하나의 점으로 표현된다***

- 직선을 찾기 위해서는 검출된 엣지 이미지(Canny 결과) 를 입력해야 함! 원본 이미지 아님!

```python
HoughLinesP(image, rho, theta, threshold1, lines, minLineLength, maxLineGap) -> lines
# image : 입력 엣지(⭐) 영상, 원본 영상이 아님
# rho (로우): 축적배열에서 rho 의 간격, 찾아나가는 거리 간격(픽셀) - 촘촘하면 오래걸리지만 검출 성능이 좋다
# theta : 축적배열에서 theta 의 간격, 각도 간격 (degree)
# lines : 선분의 끝좌표 (x1, y1, x2, y2)
# srn = None, stn = None
# minLineLength = 검출한 선분의 최소 길이 (이 길이 이상만 직선으로 인정)
# maxLineGap = 직선으로 간주할 최대 에지 점 간격 (직선 연결 판단할 기준 : 끊긴 거리가 30 이상이면 두 개의 다른 직선, 30 미만이라면 하나의 직선으로 인정)
```
### Hough 직선 시각화

```python
img = cv2.imread(Path(folder, "chessboard.jpg"))

edge = cv2.Canny(img, 100, 200)

# 시작점과 끝점을 반환
lines = cv2.HoughLinesP(edge, 1, np.pi/360, 100, minLineLength= 10, maxLineGap= 30)  # rho = 1(픽셀 1개씩 촘촘히 찾아라)
print(lines.shape)  # (라인 개수, 시작점, 끝점) = (122, 1, 4) : 원본 → 에지 → 122개의 직선 검출 

cv2.imshow("img", img)
cv2.imshow("canny", edge)

while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

#### 결과 확인

- 원본 / canny 엣지 검출

 ![image.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-25%20235316.png)

### hough transform 라인 검출 : 이미지에 존재하는 직선 검출

- 직선을 빨간색으로 그려줄 것 >> 즉, 흑백(grayscale) 이미지를 -> 컬러(colorscale) 변환시켜야 한다

- pt1 : (x1, y1)
- pt2 : (x2, y2)


```python
img = cv2.imread(Path(folder, "chessboard.jpg"))

edge = cv2.Canny(img, 100, 200)

# 시작점과 끝점을 반환
lines = cv2.HoughLinesP(edge, 1, np.pi/360, 100, minLineLength= 10, maxLineGap= 30) 
# print(lines.shape)  # (122, 1, 4) -> (라인 개수 : 122, 시작점, 끝점)
# print(lines[0][0])    # [343 562 343  75] -> [x1, y1, x2, y2]

# grayscale -> colorscale
dst = cv2.cvtColor(edge, cv2.COLOR_GRAY2BGR)

for i in range(len(lines)): # 122 개의 라인을 하나씩 가져와서 이미지 위에 그리기
    pt1 = (lines[i][0][0], lines[i][0][1])   # 
    pt2 = (lines[i][0][2], lines[i][0][3])
    cv2.line(dst, pt1, pt2, (0, 0, 255), 1, cv2.LINE_AA)


cv2.imshow("img", img)
cv2.imshow("Hough lines detection", dst)

while True:
    if cv2.waitKey() == ord("q"):
        break

cv2.destroyAllWindows()
```

#### 결과 확인

- 체스보드 패턴에서 뚜렷하게 직선을 추출하는 모습 확인 가능

- 원본 / Hough transform 이용한 122 개의 직선 검출

![image.png](/assets/img/opencv/3_opencv_실습_files/스크린샷%202025-11-26%20000533.png)

-----

#### Summary

##### 엣지 검출
- Sobel — 1차 미분 기반 기본 엣지 검출법

- Canny — 가장 안정적이고 강력한 엣지 검출법

##### 직선 검출
- Hough Transform — 엣지 기반의 직선 검출 방법
